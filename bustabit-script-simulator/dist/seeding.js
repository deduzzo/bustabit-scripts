/**
 * Bustabit Provably Fair Seeding Algorithm
 *
 * This module implements the new provably fair seeding algorithm for bustabit.
 * It includes hash chain verification, BLS signature validation, and game result calculation.
 */
import { sha256 } from "@noble/hashes/sha256";
import { hmac } from "@noble/hashes/hmac";
import { bytesToHex, concatBytes, utf8ToBytes } from "@noble/hashes/utils";
import { bls12_381 as bls } from "@noble/curves/bls12-381";
/**
 * The terminating hash of the 100,000,000 game hash chain.
 * This is the hash of game #1.
 */
export const TERMINATING_HASH = "567a98370fb7545137ddb53687723cf0b8a1f5e93b1f76f4a1da29416930fa59";
/**
 * VX's BLS public key used for signature verification.
 */
export const VX_PUBKEY = "b40c94495f6e6e73619aeb54ec2fc84c5333f7a88ace82923946fc5b6c8635b08f9130888dd96e1749a1d5aab00020e4";
/**
 * Maximum number of games in the hash chain.
 */
export const MAX_GAME_ID = 100000000;
/**
 * Verifies if a hash is part of the game hash chain.
 *
 * The chain is generated by recursively hashing the binary value of the previous hash,
 * starting from a secret and ending at the TERMINATING_HASH (game #1).
 *
 * @param hash - The hash to verify (as Uint8Array)
 * @returns The game ID if the hash is in the chain, or null if not found
 *
 * @example
 * ```typescript
 * const hash = hexToBytes("70eed5c29bde5132f4e41ec8b117a31533e5b055c6c21174d932b377a1855a04");
 * const gameId = verifyInChain(hash);
 * if (gameId) {
 *   console.log(`Hash is in the chain. It is game: ${gameId}`);
 * } else {
 *   console.log("Hash is not in the chain");
 * }
 * ```
 */
export function verifyInChain(hash) {
    let currentHash = hash;
    for (let gameId = 1; gameId <= MAX_GAME_ID; gameId++) {
        currentHash = sha256(currentHash);
        if (bytesToHex(currentHash) === TERMINATING_HASH) {
            return gameId;
        }
    }
    return null;
}
/**
 * Validates a VX signature for a game.
 *
 * VX signs the concatenation of the previous game hash and the game salt
 * using BLS signatures, ensuring only one valid signature can exist per message.
 *
 * @param gameSalt - The hash of Bitcoin block 831500 (lowercase hex)
 * @param prevGameHash - The hash of the previous game (as Uint8Array)
 * @param vxSignature - The VX signature to validate (as Uint8Array)
 * @returns True if the signature is valid, false otherwise
 *
 * @example
 * ```typescript
 * const gameSalt = "abc123..."; // Bitcoin block 831500 hash
 * const prevGameHash = hexToBytes("70eed5c29bde5132f4e41ec8b117a31533e5b055c6c21174d932b377a1855a04");
 * const vxSignature = hexToBytes("...");
 *
 * if (validateSignature(gameSalt, prevGameHash, vxSignature)) {
 *   console.log("Signature is valid");
 * } else {
 *   console.log("Invalid signature");
 * }
 * ```
 */
export function validateSignature(gameSalt, prevGameHash, vxSignature) {
    try {
        const message = concatBytes(prevGameHash, utf8ToBytes(gameSalt));
        return bls.verify(vxSignature, message, VX_PUBKEY);
    }
    catch (error) {
        return false;
    }
}
/**
 * Calculates the game result (crash point) from a VX signature and game hash.
 *
 * The algorithm:
 * 1. Calculate HMAC_SHA256(key=signature, message=hash)
 * 2. Extract r = 52 most significant bits
 * 3. Calculate X = r / 2^52 (uniformly distributed in [0, 1))
 * 4. Calculate X = 99 / (1 - X)
 * 5. Return max(1, floor(X) / 100)
 *
 * @param vxSignature - The VX signature (as Uint8Array)
 * @param gameHash - The game hash (as Uint8Array)
 * @returns The crash point as a multiplier (e.g., 1.50 means 1.50x)
 *
 * @example
 * ```typescript
 * const vxSignature = hexToBytes("...");
 * const gameHash = hexToBytes("70eed5c29bde5132f4e41ec8b117a31533e5b055c6c21174d932b377a1855a04");
 *
 * const crashPoint = gameResult(vxSignature, gameHash);
 * console.log(`Game crashed at: ${crashPoint.toFixed(2)}x`);
 * ```
 */
export function gameResult(vxSignature, gameHash) {
    const nBits = 52; // number of most significant bits to use
    // 1. HMAC_SHA256(key=signature, message=hash)
    const hash = bytesToHex(hmac(sha256, vxSignature, gameHash));
    // 2. r = 52 most significant bits
    const seed = hash.slice(0, nBits / 4);
    const r = Number.parseInt(seed, 16);
    // 3. X = r / 2^52
    let X = r / Math.pow(2, nBits); // uniformly distributed in [0; 1)
    // 4. X = 99 / (1 - X)
    X = 99 / (1 - X); // 1 - X so there's no chance of div-by-zero
    // 5. return max(trunc(X), 100)
    const result = Math.floor(X);
    return Math.max(1, result / 100);
}
//# sourceMappingURL=seeding.js.map